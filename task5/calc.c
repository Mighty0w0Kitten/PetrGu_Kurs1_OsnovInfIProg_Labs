#include <stdio.h>  // Для ввода/вывода
#include <stdlib.h> // Для работы с памятью (например, malloc, free), а также для функции exit()
#include <string.h> // Для работы со строками (например, fgets, strcmp, strcspn, memcpy)
#include <ctype.h> // Для работы с символами (например, isdigit, isalpha, isspace)

#include "rat_io.h" // Для работы с вводом/выводом рациональных чисел
#include "rat_math.h" // Для выполнения математических операций с рациональными числами
#include "rational.h"

// Функция для проверки корректности оператора
int is_valid_operator(char operator) {
	return (operator == '+' || operator == '-' || operator == '*' || operator == '/');
}

// Функция для проверки корректности рациональных чисел (например, "3/4" или "5")
int is_valid_rational(const char *str) {
	rational_t temp;
	return rat_parse(str, &temp); // Используем функцию парсинга для проверки
}

// Функция для разбора выражения и проверки корректности
int parse_expression(const char *input, rational_t *op1, rational_t *op2, char *operator, rational_t last_result) {

	char op1_str[50], op2_str[50];
	int operator_count = 0;
	int in_fraction = 0;  // Флаг для проверки, находимся ли мы внутри дроби

	// Пройдем по строке, чтобы подсчитать количество операторов
	for (int i = 0; input[i] != '\0'; i++)
	{
		if (input[i] == '/')
		{  // Если это символ дроби
			in_fraction = 1;
		}
		else if (in_fraction && (input[i] == ' ' || input[i] == '+' || input[i] == '-' || input[i] == '*' || input[i] == '/'))
		{
			in_fraction = 0;  // Конец дроби
		}
		else if (!in_fraction && (input[i] == '+' || input[i] == '-' || input[i] == '*' || input[i] == '/'))
		{
			operator_count++;  // Увеличиваем счетчик операторов
		}
	}
'\0'
	// Разбор строки на операнды и оператор
	int n = sscanf(input, "%s %c %s", op1_str, operator, op2_str);

	// Проверка на корректность парсинга (должно быть 3 элемента: два операнда и оператор)
	if (n != 3 || operator_count != 1)
	{
		printf("Ошибка: некорректный ввод. Ожидается выражение вида 'число оператор число'.\n");
		return 0;
	}

	// Проверка оператора на допустимость
	if (!is_valid_operator(*operator))
	{
		printf("Ошибка: недопустимый оператор. Используйте +, -, * или /.\n");
		return 0;
	}

	// Подстановка last для первого операнда
    	if (strcmp(op1_str, "last") == 0)
	{
		*op1 = last_result;
	}
	else if (!rat_parse(op1_str, op1))
	{
		printf("Ошибка: некорректный первый операнд '%s'. Ожидается рациональное число.\n", op1_str);
		return 0;
	}

	 // Подстановка last для второго операнда
	if (strcmp(op2_str, "last") == 0)
	{
		*op2 = last_result;
	}
	else if (!rat_parse(op2_str, op2))
	{
		printf("Ошибка: некорректный второй операнд '%s'. Ожидается рациональное число.\n", op2_str);
		return 0;
	}

	// Если все проверки пройдены, возвращаем успешный результат
	return 1;
}

int main() {
	/*Объявляем массив символов input размером 100 для хранения введённой строки.*/
	char input[100]; // Буфер для ввода строки с выражением
	rational_t op1, op2, result; // Переменные для хранения операндов
	rational_t last_result = rat_from_int(0);
	// Переменная для хранения последнего результата (инициализация нулем)
	char operator; // Переменная для хранения оператора

	while (1) // Бесконечный цикл для ввода данных
	{
		// Ввод строки с выражением
		printf("Введите выражение (например, 3/4 + 5/6) или 'exit' для выхода: ");
		fgets(input, sizeof(input), stdin);

		// Удаление символа новой строки, если он присутствует
                input[strcspn(input, "\n")] = '\0';

		// Проверка на команду выхода 'exit'
                if (strcmp(input, "exit") == 0)
                {
                        printf("Программа завершена по команде пользователя.\n");
                        break;
                }

		// Разбор и проверка корректности выражения
		 if (parse_expression(input, &op1, &op2, &operator, last_result))
		{
			// Выполнение вычислений в зависимости от оператора
			switch (operator)
			{
				case '+':result = rat_add(op1, op2);break;
				case '-':result = rat_sub(op1, op2);break;
				case '*':result = rat_mul(op1, op2);break;
				case '/':
					if (rat_num(op2) == 0)
					{
						printf("Ошибка: деление на ноль.\n");
						continue;  // Переходим к следующему вводу
					}
					result = rat_div(op1, op2); break;
				default:
					printf("Ошибка: недопустимый оператор.\n");
					continue;
			}

			// Обновляем last_result после успешной операции
			last_result = result;

			// Вывод результата
			printf("Результат: ");
			rat_printf(result);
			printf("\n");
		}

	}

	return 0;
}





/*
###fgets(input, sizeof(input), stdin)
Используем fgets для чтения строки из стандартного ввода.
Эта функция безопасна, так как ограничивает длину вводимых данных размером буфера.

###Что значат и делают элементы строки fgets(input, sizeof(input), stdin) == NULL?
- fgets(input, sizeof(input), stdin):
	- Это функция для чтения строки из стандартного ввода (stdin).
	- input — массив, куда будет записана строка.
	- sizeof(input) — максимальное количество символов, которое можно прочитать,
	  включая завершающий символ \0.
	- stdin — поток ввода, откуда читаются данные (в данном случае — клавиатура).

###Удаление символа новой строки
После ввода строки с помощью fgets, она может содержать символ \n, добавляемый при нажатии Enter.
Удаляем его с помощью input[strcspn(input, "\n")] = '\0';.

###Зачем нужно "Удаление символа новой строки, если он присутствует"?
Когда вы вводите данные с клавиатуры, нажатие клавиши Enter добавляет символ новой строки (\n) в конец строки.
Если его не удалить:
	-Это может мешать дальнейшей обработке строки, так как символ \n будет восприниматься как часть данных.
	-Например, при сравнении с командами (strcmp) или разборе строки (sscanf), присутствие \n вызовет ошибки.
Удаляя символ новой строки, мы получаем "чистую" строку, которую проще обрабатывать.

###Что значит и делает strcspn?
strcspn(const char *str, const char *delim):
	- Находит позицию первого символа в строке str, который присутствует в строке delim.
	- Возвращает количество символов до первого совпадения или длину строки, если совпадений нет.
Пример:
	char input[] = "hello\n";
	size_t pos = strcspn(input, "\n");
	// pos будет равно 5, так как '\n' находится на 5-й позиции (счёт с 0).
Использование:
	Если символ новой строки (\n) найден, его можно заменить на \0 (терминатор строки),
	effectively "обрезав" строку.

###Что значит и делает strcmp?
strcmp(const char *str1, const char *str2):
	- Сравнивает две строки str1 и str2 символ за символом.
Возвращаемое значение:
	- 0 — если строки равны.
	- < 0 — если str1 лексикографически меньше str2.
	- > 0 — если str1 лексикографически больше str2.
Пример:
	if (strcmp(input, "exit") == 0)
	{
		printf("Выход из программы\n");
	}
В этом случае, если пользователь ввёл exit, функция вернёт 0, и программа завершится.

###Цикл while (1)
Цикл while (1): этот цикл будет бесконечно выполнять обработку ввода до тех пор, пока не встретится команда exit.

###Как работает "if (n != 3)"
Эта часть кода проверяет результат парсинга введённой строки с выражением на корректность. Разберем её подробнее:
1."int n = sscanf(input, "%s %c %s", op1, operator, op2)" - в этой строке происходит разбор строки input
  с помощью функции sscanf.
	- Функция sscanf используется для чтения данных из строки и их преобразования в указанные переменные.
	  В данном случае она ищет в строке:
		- %s — строку (для первого операнда, op1),
		- %c — одиночный символ (для оператора, operator),
		- %s — строку (для второго операнда, op2).
	- Результат парсинга сохраняется в переменной n, которая указывает, сколько значений было
	  успешно извлечено из строки.
2.if (n != 3) — это условие проверяет, было ли извлечено именно 3 элемента:
- два операнда (op1 и op2),
- один оператор (operator).
- Если значение переменной n не равно 3, это означает, что строка не была правильно разобрана (например,
  если строка была недостаточно длинной, неправильно оформлена или в ней отсутствовал один из операндов или
  оператор).
3.printf("Ошибка: некорректный ввод. Ожидается выражение вида 'число оператор число'.\n"); — если
  условие n != 3 выполняется, то выводится сообщение об ошибке, информирующее пользователя о том, что
  ввод некорректен.
4.return 0; — после вывода ошибки функция parse_expression завершает выполнение и возвращает 0,
  сигнализируя, что ввод был некорректным. Это также останавливает дальнейшую обработку ввода в основном цикле.
Таким образом, эта часть кода выполняет проверку того, что строка, введённая пользователем, соответствует
ожидаемому формату выражения: "операнд1 оператор операнд2". Если формат нарушен, пользователю выводится ошибка.

###Подсчёт количества операторов
Значение, возвращаемое функцией strlen(), имеет тип size_t, что является беззнаковым типом.
Чтобы избавиться от предупреждения при команде make, явно приводим тип переменной i к size_t, как это делают
при работе с длиной строки.

###Цикл подсчёта операторов
1. Цикл по строке:
for (int i = 0; input[i] != '\0'; i++)
	- Этот цикл проходит по каждому символу строки input до символа завершения строки ('\0').
	- Переменная i — индекс символа в строке.
2. Проверка на символ дроби:
if (input[i] == '/')
{
    in_fraction = 1;  // Если это символ дроби
}
	- Когда мы встречаем символ /, это начало дроби (например, в выражении 2/3).
	- Устанавливаем флаг in_fraction = 1, который говорит, что находимся внутри дроби.
3. Проверка на конец дроби:
else if (in_fraction && (input[i] == ' ' || input[i] == '+' || input[i] == '-' || input[i] == '*' || input[i] == '/'))
{
    in_fraction = 0;  // Конец дроби
}
	- Если мы находимся внутри дроби (in_fraction == 1), мы проверяем, если встречается один из символов: пробел, оператор (+, -, *, /).
	- Это означает, что мы вышли из дроби (дробь заканчивается, и начинается следующий операнд или оператор).
	- В таком случае мы сбрасываем флаг in_fraction = 0.
4. Подсчет операторов, если не в дроби:
else if (!in_fraction && (input[i] == '+' || input[i] == '-' || input[i] == '*' || input[i] == '/'))
{
    operator_count++;  // Увеличиваем счетчик операторов
}
	- Если мы не находимся внутри дроби (in_fraction == 0), и текущий символ является одним из операторов (+, -, *, /), то
	  увеличиваем счетчик операторов operator_count++.
	- Этот блок выполняется только для операторов, которые находятся между операндами, а не внутри дробей.











*/
