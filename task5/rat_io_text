###какой путь пройдёт строка 4/5

Давайте разберём, какой путь пройдёт строка "4/5" при использовании функции rat_scanf:

int rat_scanf(const char *str, rational_t *r) {
    int num, denom;

    /* Пробуем прочитать строку как дробь (формат "числитель/знаменатель") */
    if (sscanf(str, "%d/%d", &num, &denom) == 2) {
        if (denom == 0) {
            return -1; /* Ошибка: деление на ноль */
        }
        *r = rational(num, denom); /* Создаём рациональное число с указанным числителем и знаменателем */
    } 
    /* Если не получилось, пробуем прочитать строку как целое число */
    else if (sscanf(str, "%d", &num) == 1) {
        *r = rational(num, 1); /* Создаём рациональное число с числителем и знаменателем 1 */
    } 
    else {
        return -1; /* Ошибка: строка не соответствует ни дроби, ни целому числу */
    }
    return 0; /* Успешное завершение */
}

Пояснение:
1. Строка "4/5" передаётся в функцию rat_scanf.
2. Функция пытается распарсить строку как дробь с использованием sscanf(str, "%d/%d", &num, &denom):
   - Числитель (num) будет равен 4.
   - Знаменатель (denom) будет равен 5.
   - Функция успешно находит дробь и записывает эти значения в переменные num и denom.
   
3. Далее проверяется, что знаменатель не равен 0. Поскольку denom == 5, то это условие проходит.
4. Создаётся рациональное число с числителем 4 и знаменателем 5 с помощью функции rational(num, denom).
5. Функция возвращает 0, что означает успешное завершение.

Таким образом, строка "4/5" будет преобразована в рациональное число с числителем 4 и знаменателем 5, 
и функция вернёт успешный результат (0).

Пример:
rational_t r;
int result = rat_scanf("4/5", &r);   // r = 4/5, result = 0 (успешно)

Если после этого вызова вывести результат с помощью rat_printf(r), то будет выведено "4/5", 
поскольку знаменатель не равен 1.


###что при этих условиях выдаст функция "void rat_printf(rational_t r)"
Функция rat_printf(rational_t r) будет отвечать за вывод рационального числа. 
Она должна проверять, если знаменатель равен 1, и если это так, выводить только числитель. 
В противном случае она будет выводить и числитель, и знаменатель.

Давайте уточним её поведение на примере. Вот как будет выглядеть её код:
void rat_printf(rational_t r) {
    int num = rat_num(r);  // Получаем числитель
    int denom = rat_denom(r);  // Получаем знаменатель

    if (denom == 1) {
        // Если знаменатель равен 1, выводим только числитель (целое число)
        printf("%d", num);
    } else {
        // Если знаменатель не равен 1, выводим дробь в виде числитель/знаменатель
        printf("%d/%d", num, denom);
    }
}

Как будет работать:

1. Строка "4/5" преобразована в рациональное число с числителем 4 и знаменателем 5.
2. При вызове rat_printf(r):
   - Функция сначала извлечёт числитель (4) и знаменатель (5) с помощью rat_num(r) и rat_denom(r).
   - Поскольку знаменатель не равен 1, функция выведет строку 4/5.

Пример:
rational_t r;
int result = rat_scanf("4/5", &r);  // r = 4/5
rat_printf(r);  // Выведет "4/5"

Если бы мы использовали строку "4" (целое число), то функция бы вывела только числитель:
rational_t r;
int result = rat_scanf("4", &r);  // r = 4/1
rat_printf(r);  // Выведет "4" (без знаменателя)

Таким образом, при данных условиях (строка "4/5") функция rat_printf(r) выведет "4/5", 
так как знаменатель не равен 1.
