ЧТО ТАКОЕ АЛГОРИТМ ЭВКЛИДА

Алгоритм Эвклида — это эффективный метод нахождения наибольшего общего делителя (НОД) двух чисел.
Он основан на идее, что НОД двух чисел равен НОД их остатка от деления. Этот алгоритм работает по 
принципу деления с остатком.

### Принцип работы алгоритма Эвклида:
1. Пусть у нас есть два числа (a) и (b), где (a > или = b).
2. Вычисляем остаток от деления (a) на (b) (обозначим его (r)):	(r = a mod b)
3. Если (r=0), то НОД — это (b). 
Если остаток не равен нулю, повторяем процесс, используя (b) и (r) как новые числа: НОД(a,b)=НОД(b,r)
4. Повторяем шаги 2 и 3 до тех пор, пока остаток не станет равным нулю. 
Когда остаток равен нулю, наибольший общий делитель — это текущий второй элемент.

### Пример:
Найдем НОД чисел 56 и 15:
1. (a = 56, b = 15)
2. Находим остаток от деления: ( 56 mod 15 = 56 - 15 x 3 = 56 - 45 = 11 )
   Теперь у нас два числа: (b = 15) и (r = 11).
3. Переходим к следующей итерации:
   (a = 15, b = 11)
   (15 mod 11 = 15 - 11 x 1 = 15 - 11 = 4)
   Теперь у нас два числа: (b = 11) и (r = 4).
4. Следующая итерация:  
   (a = 11, b = 4)
   (11 mod 4 = 11 - 4 x 2 = 11 - 8 = 3)
   Теперь у нас два числа: (b = 4) и (r = 3).

5. Следующая итерация:  
   (a = 4, b = 3)
   (4 mod 3 = 4 - 3 x 1 = 4 - 3 = 1)
   Теперь у нас два числа: (b = 3) и (r = 1).

6. Следующая итерация:  
   (a = 3, b = 1)
   (3 mod 1 = 0)
   Остаток равен нулю, поэтому НОД = 1.

### Почему это работает:
Алгоритм Эвклида основан на том, что НОД чисел не меняется при замене большего числа 
на остаток от деления на меньшее. Например, если (a) делится на (b) с остатком (r), 
то НОД чисел (a) и (b) будет таким же, как НОД чисел (b) и (r).

### Преимущества:
- Алгоритм работает очень быстро даже для больших чисел.
- Он является основой для многих криптографических методов, таких как алгоритм RSA.





ЧТО ТАКОЕ "mod"
Операция mod (сокращение от "модуль") — это операция нахождения остатка от деления одного числа на другое.
Это означает, что при делении одного числа на другое, операция mod возвращает остаток, 
который остаётся после деления.

### Формально:
Если (a) — это делимое, а (b) — делитель, то операция (a mod b) возвращает остаток от деления (a) на (b).

### Математически:
a mod b = a - b x |a/b|
где |a/b| — это целая часть от деления (a) на (b), то есть результат деления без остатка.

### Пример:
Пример 1: (17 mod 5)
1. Делим 17 на 5: (17 / 5 = 3) (целая часть).
2. Умножаем 5 на 3: (5 x 3 = 15).
3. Вычитаем 15 из 17: (17 - 15 = 2).
Ответ: (17 mod 5 = 2), то есть остаток от деления 17 на 5 равен 2.

Пример 2: (23 mod 6)
1. Делим 23 на 6: (23 / 6 = 3) (целая часть).
2. Умножаем 6 на 3: (6 x 3 = 18).
3. Вычитаем 18 из 23: (23 - 18 = 5).
Ответ: (23 mod 6 = 5).

### Особенности:
- Если (a) делится на (b) без остатка, то (a mod b = 0).
- Операция mod может быть полезной в разных областях, таких как обработка циклических структур, алгоритмы, 
криптография и т. д.





ЧТО ТАКОЕ ОСТАТОК ОТ ДЕЛЕНИЯ

Остаток от деления — это величина, которая остаётся после того, как одно число делится на другое, 
и результат деления не является целым числом.

Когда мы делим одно число (a) на другое (b), в большинстве случаев результат не является целым числом.
Остаток — это именно та часть, которая "не помещается" в целую часть от деления.

### Объяснение на примере:
Рассмотрим операцию деления (17÷5).

1. Целая часть от деления — это количество полных делений, которое можно выполнить. 
   Например: 17÷5=3 (целая часть).
   Это значит, что 5 умещается в 17 три раза, и оставшаяся часть будет "неполной".

2. Остаток — это то, что остаётся после того, как вы вычли результат умножения целой части на делитель:
   17 - (5 x 3) = 17 - 15 = 2.
   Остаток от деления 17 на 5 равен 2.

Итак, остаток от деления — это то, что не может быть разделено на делитель целыми частями.

### Формально:
Если (a) — это делимое, а (b) — делитель, то при делении (a) на (b) можно записать:
a = b x |a/b| + остаток, где |a/b| — это целая часть от деления, а остаток — это то, что остаётся.

### Пример 1:
Для (17÷5):
- Целая часть = 3.
- Остаток = 2.
- (17 = 5 x 3 + 2).

### Пример 2:
Для (23 ÷ 6):
- Целая часть = 3.
- Остаток = 5.
- (23 = 6 ÷ 3 + 5).

### Пример с отрицательными числами:
Для (-17 ÷ 5):
- Целая часть = -4 (потому что -17 делится на 5 четыре раза с округлением вниз).
- Остаток = 3.
- (-17 = 5 x (-4) + 3).

### Когда остаток равен 0:
Если делимое делится нацело на делитель, остаток будет равен 0. Например: 20 ÷ 5 = 4 (остаток 0).

### Важные моменты:
- Остаток всегда меньше делителя по абсолютной величине. То есть, если (a mod b = r), то (0 =< r < |b|).
- Для положительных чисел остаток всегда будет положительным или нулём, а для отрицательных 
чисел результат может зависеть от знака делителя.





ЧТО ЗНАЧИТЬ ЗАЩИТА ОТ ПОВТОРОНОГО ВКЛЮЧЕНИЯ?

Защита от повторного включения — это механизм, который предотвращает повторное включение одного и 
того же заголовочного файла в программе. Если заголовочный файл включён несколько раз 
(например, через другие заголовочные файлы), это может привести к ошибкам компиляции, 
таким как повторное определение типов, функций или переменных.

Как работает защита от повторного включения:

1. #ifndef и #define:
	- #ifndef проверяет, определён ли макрос (в данном случае RAT_MATH_H).
	- Если макрос не определён, компилятор включает содержимое файла.
	- #define создаёт этот макрос, чтобы отметить, что файл уже включён.
2. #endif:
	- Закрывает условную компиляцию, начатую с #ifndef.

Пример:

Предположим, у нас есть два файла: "file1.c" и "file2.c"
Оба включают один и тот же заголовочный файл, например, rat_math.h.

Без защиты:
	// rat_math.h
	typedef struct 
	{
		int num;
		unsigned int denom;
	} rational_t;
	// Ошибка: многократное определение структуры rational_t!

С защитой:
	#ifndef RAT_MATH_H
	#define RAT_MATH_H
	typedef struct 
	{
		int num;
		unsigned int denom;
	} rational_t;
	#endif

Теперь, при втором включении, макрос RAT_MATH_H уже будет определён, и содержимое файла не включится повторно.

Итог:
Защита от повторного включения гарантирует, что один и тот же заголовочный файл будет обработан 
компилятором ровно один раз. Это обязательный приём в C и C++ для предотвращения ошибок 
компиляции в больших проектах.





ЧТО ТАКОЕ ПАРСИНГ

Парсинг (от англ. parsing) — это процесс анализа и преобразования данных из одной формы в другую, 
чаще всего из строки (текста) в структурированный формат. Например, если строка "3/4" представляет 
рациональное число, парсинг означает извлечение чисел 3 и 4 и представление их в виде числителя и знаменателя.





ЧТО ТАКОЕ sscanf

Функция sscanf в языке C используется для извлечения данных из строки, преобразуя их в указанные 
переменные согласно заданному формату. Это можно рассматривать как "обратный" процесс по 
отношению к функции printf, которая выводит данные в строку.

Синтаксис функции sscanf
int sscanf(const char *str, const char *format, ...);

str — строка, из которой будут извлекаться данные.
format — строка формата, которая указывает, в каком формате нужно извлекать данные.
... — список переменных, в которые будут помещены извлеченные данные, в зависимости от формата.

Возвращаемое значение

Функция sscanf возвращает количество успешно считанных и распарсенных элементов. 
Если строка не соответствует формату, возвращаемое значение может быть меньше ожидаемого, 
и в этом случае можно проверить это для обработки ошибок.

Пример работы функции sscanf
Допустим, у нас есть строка с дробью, и мы хотим извлечь числитель и знаменатель:
#include <stdio.h>
int main() {
    char str[] = "5/7";
    int num, denom;

    // Извлекаем числитель и знаменатель
    int result = sscanf(str, "%d/%d", &num, &denom);

    // Если удачно распарсили два значения
    if (result == 2) {
        printf("Числитель: %d, Знаменатель: %d\n", num, denom);
    } else {
        printf("Ошибка в формате строки\n");
    }

    return 0;
}

Что происходит:
1.В строке "5/7" ищем два целых числа, разделенных символом /.
2.Функция sscanf извлекает числитель (5) и знаменатель (7) и сохраняет их в переменные num и denom.
3.Если оба значения успешно извлечены, выводится результат. 
  В противном случае мы получим сообщение о неправильном формате.

Формат спецификаторов
В строке формата могут быть различные спецификаторы, например:
- %d — для целых чисел.
- %f — для чисел с плавающей точкой.
- %s — для строк (массивов символов).
- %ld — для длинных целых чисел.
- %c — для одиночных символов.

Каждый спецификатор соответствует определенному типу данных, 
который должен быть передан в соответствующую переменную.

Пример с разбором даты:
#include <stdio.h>
int main() {
    char date[] = "2025-01-06";
    int year, month, day;

    // Извлекаем год, месяц и день
    int result = sscanf(date, "%d-%d-%d", &year, &month, &day);

    if (result == 3) {
        printf("Год: %d, Месяц: %d, День: %d\n", year, month, day);
    } else {
        printf("Ошибка в формате даты\n");
    }

    return 0;
}

Основные моменты:
- sscanf использует строку формата, чтобы "прочитать" данные из строки.
- Результат работы зависит от того, сколько значений удается извлечь по заданному формату.
- Применяется для парсинга строковых данных в другие типы данных, такие как числа или даты.





#Зачем вообще делать этот этап? Для чего нужна эта библиотека и как это влияет на программу?

Этот этап работы с библиотеками важен для повышения гибкости и удобства работы с кодом, 
особенно в более крупных и сложных проектах. Давайте разберемся, зачем нужно использовать библиотеки и 
как это влияет на программу.

### Причины использования библиотек:

1. **Повторное использование кода**:
   - Вы можете отделить общие и часто используемые части программы, такие как операции с рациональными числами, 
     в отдельную библиотеку. Это позволяет использовать один и тот же код в разных программах, 
     без необходимости копировать его каждый раз.
   - Например, если в будущем вам нужно будет написать другую программу для работы с рациональными числами, 
     вы сможете просто подключить эту библиотеку и использовать её функции.

2. **Управление зависимостями и упрощение сборки**:
   - Создание библиотеки позволяет вам разделить проект на несколько частей, 
     что делает его более структурированным и понятным.
   - В процессе компиляции вы компилируете модули библиотеки один раз, 
     и каждый раз при сборке программы достаточно подключить её кода без повторной компиляции.
   - Это также упрощает обновление или модификацию библиотеки: если нужно улучшить или исправить один из модулей 
     (например, исправить баг в расчётах с рациональными числами), вам достаточно изменить только саму библиотеку 
     и пересобрать программу.

3. **Уменьшение размера исполняемого файла**:
   - Если вы используете статическую библиотеку, она включается в состав исполняемого файла, 
     что позволяет создать один компактный файл, который не зависит от наличия внешних библиотек.
   - В случае с динамической библиотекой сама программа становится меньше, так как библиотеки остаются отдельными 
     файлами, которые загружаются при старте программы, а не встроены в сам исполняемый файл.

4. **Удобство работы с большими проектами**:
   - В проектах с множеством исходных файлов, разделение функциональности на отдельные модули и создание библиотек 
     помогает структурировать проект. Это облегчает поддержку и модификацию кода.
   - Модули, такие как `rat_math`, `rat_io` и `rational`, могут быть разработаны и протестированы отдельно, 
     а затем подключены к основной программе (в вашем случае, программе `calc`).

### Как это влияет на программу:

1. **Упрощение сборки**:
   - Вместо того, чтобы каждый раз компилировать и связывать исходный код функций для работы с рациональными 
     числами, вы просто подключаете библиотеку, и компилятор ссылается на неё.
   - Это ускоряет процесс сборки, так как вы компилируете библиотеку один раз, а программу компилируете быстрее, 
     без необходимости включать повторяющиеся части кода.

2. **Изоляция изменений**:
   - Если вам нужно изменить реализацию, например, добавить новый алгоритм для работы с рациональными числами, 
     вам нужно будет изменить только библиотеку, а не все части программы.
   - Это уменьшает вероятность ошибок и облегчает тестирование и отладку.

3. **Гибкость при обновлениях**:
   - При использовании динамической библиотеки вы можете обновить библиотеку, не перекомпилируя основную программу. 
     Это позволяет фиксировать ошибки или обновлять функциональность без необходимости пересобирать и переназначать 
     всё приложение.

4. **Обмен и использование сторонних библиотек**:
   - Библиотеки могут быть легко обменены между разными проектами, а также использовать сторонние решения. 
     Это упрощает масштабирование и развитие вашего приложения, потому что вы можете адаптировать уже готовые 
     решения для работы с рациональными числами.

### Статическая vs. Динамическая библиотеки

- **Статическая библиотека** (`librational.a`):
  - Все необходимые функции будут включены в исполняемый файл программы. Это делает программу независимой от 
    внешних файлов и упрощает её распространение, но увеличивает размер исполняемого файла.

- **Динамическая библиотека** (`librational.so`):
  - Программа будет зависеть от этой библиотеки при запуске, что делает её размер меньше. Однако для работы 
    программы обязательно наличие библиотеки на системе пользователя.

### Влияние на вашу программу:
В вашем случае использование библиотеки с функциями работы с рациональными числами улучшает организацию программы, 
позволяя вам использовать один и тот же код в разных местах. При добавлении новых функций или исправлении ошибок 
в математических операциях с рациональными числами, вы просто обновляете библиотеку, не затрагивая основную 
программу.

Это также поможет вам упростить код программы `calc`, так как её логика будет сосредоточена только на 
взаимодействии с пользователем и использовании функций из библиотеки, а не на реализации самой работы с 
рациональными числами.










































